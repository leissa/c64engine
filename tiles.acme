!macro copy_tile_char .char {
    ldy #0
    lda TILE_CLR+(.char*TILES), x ; todo: consider page bounderies for TILES
    sta (CLR_POS_LO_T), y ; equals SCR_POS_LO_T, but HI is different

    +set ALL_RAM, RAM_ROM_SELECTION ; todo: can we improve this?

    lda TILE_SCR+(.char*TILES), x
    sta (SCR_POS_LO_T), y

    !for .row, 0, 7 {
        lda TILE_PIX+(.char*8*TILES)+(.row*TILES), x
        sta (PIX_POS_LO_T), y
        !if .row != 7 {
            iny
        }
    }

    +set ALL_RAM_WITH_IO, RAM_ROM_SELECTION
    rts
}

copy_tile_char0 !zone { +copy_tile_char 0 }
copy_tile_char1 !zone { +copy_tile_char 1 }
copy_tile_char2 !zone { +copy_tile_char 2 }
copy_tile_char3 !zone { +copy_tile_char 3 }
copy_tile_char4 !zone { +copy_tile_char 4 }
copy_tile_char5 !zone { +copy_tile_char 5 }

!macro iterate_pointers .cols {
!if .cols = 1 {
    !set .tile_char = C_TILE_COL
} else {
    !set .tile_char = R_TILE_ROW
}
    lda .tile_char
    adc #1
    !if .cols = 1 {
        cmp #TILE_COLS
    } else {
        cmp #TILE_ROWS
    }
    sta .tile_char
    bne +
    clc
    lda #0
    sta .tile_char

!if .cols = 1 {
    inc MAP_POS_LO_T
    bne +
    inc MAP_POS_HI_T
} else {
    ; speed up if TILE_ROWS = 2
    ; lda .tile_char
    ; adc #1
    ; and #1
    ; sta .tile_char
    ; bne +

    ; example map is 256 tiles wide
    ; lda MAP_POS_LO_T
    ; adc #MAP_WIDTH
    ; sta MAP_POS_LO_T
    ; bcc +
    ; clc
    inc MAP_POS_HI_T
}
+
    ; pixel pointer
    lda PIX_POS_LO_T
    adc #(8*.cols % 256) ; + 64
    sta PIX_POS_LO_T

    lda PIX_POS_HI_T
    adc #(8*.cols / 256) ; + 256
    and #%11011111 ; modulo 8192 (but keep upper bits)
    sta PIX_POS_HI_T ; next pixel position to start from

    ; color pointers
    lda SCR_POS_LO_T
    adc #.cols
    sta SCR_POS_LO_T ; next screen position to start from
    sta CLR_POS_LO_T
    bcc +
    clc

    lda SCR_POS_HI_T
    adc #1
    and #%11111011 ; modulo 1024 (but keep upper bits)
    sta SCR_POS_HI_T

    lda CLR_POS_HI_T
    adc #1
    and #%11111011 ; module 1024 (but keep upper bits)
    sta CLR_POS_HI_T
+
}

!macro copy_tile_char_and_iterate .cols {
!if .cols = 1 {
    !set .tile_col = C_TILE_COL
    !set .tile_row = C_TILE_ROW
} else {
    !set .tile_col = R_TILE_COL
    !set .tile_row = R_TILE_ROW
}

;.map_pos
    ldy #0
    lda (MAP_POS_LO_T), y
    tax
;    ldx TILE_MAP           ; x = tile index

    ; pixel pointer
    lda .tile_row
    beq +
    lda #TILE_COLS         ; a = TILE_COLS * tile_row (TILE_ROWS = 2)
+
    adc .tile_col

    ; use char and tile index to copy_tile_chars
    !for .char, 0, 5 {
        !if .char != 5 {
            cmp #.char
            bne +
        }
        !if .char = 0 { jsr copy_tile_char0 }
        !if .char = 1 { jsr copy_tile_char1 }
        !if .char = 2 { jsr copy_tile_char2 }
        !if .char = 3 { jsr copy_tile_char3 }
        !if .char = 4 { jsr copy_tile_char4 }
        !if .char = 5 { jsr copy_tile_char5 }
        !if .char != 5 { jmp .iterate }
+
    }

.iterate
    clc
    +iterate_pointers .cols
}

!macro init_pointers .cols {
!if .cols = 1 {
    !set .tile_col = C_TILE_COL
    !set .tile_row = C_TILE_ROW
    !set .map_pos_lo = C_MAP_POS_LO
    !set .map_pos_hi = C_MAP_POS_HI
;    !set .map_pos1 = c_map_pos1
    !set .pix_pos_lo = C_PIX_POS_LO
    !set .pix_pos_hi = C_PIX_POS_HI
    !set .scr_pos_lo = C_SCR_POS_LO
    !set .scr_pos_hi = C_SCR_POS_HI
    !set .map_pos_lo_t = C_MAP_POS_LO_T
    !set .map_pos_hi_t = C_MAP_POS_HI_T
    !set .pix_pos_lo_t = C_PIX_POS_LO_T
    !set .pix_pos_hi_t = C_PIX_POS_HI_T
    !set .scr_pos_lo_t = C_SCR_POS_LO_T
    !set .scr_pos_hi_t = C_SCR_POS_HI_T
    !set .clr_pos_hi_t = C_CLR_POS_HI_T
} else {
    !set .tile_col = R_TILE_COL
    !set .tile_row = R_TILE_ROW
    !set .map_pos_lo = R_MAP_POS_LO
    !set .map_pos_hi = R_MAP_POS_HI
;    !set .map_pos1 = r_map_pos1
    !set .pix_pos_lo = R_PIX_POS_LO
    !set .pix_pos_hi = R_PIX_POS_HI
    !set .scr_pos_lo = R_SCR_POS_LO
    !set .scr_pos_hi = R_SCR_POS_HI
    !set .map_pos_lo_t = R_MAP_POS_LO_T
    !set .map_pos_hi_t = R_MAP_POS_HI_T
    !set .pix_pos_lo_t = R_PIX_POS_LO_T
    !set .pix_pos_hi_t = R_PIX_POS_HI_T
    !set .scr_pos_lo_t = R_SCR_POS_LO_T
    !set .scr_pos_hi_t = R_SCR_POS_HI_T
    !set .clr_pos_hi_t = R_CLR_POS_HI_T
}

    lda TILE_COL
    sta .tile_col
    lda TILE_ROW
    sta .tile_row

    lda .map_pos_lo
    sta .map_pos_lo_t
;    sta .map_pos1 + (22 + 5 + 1)

    clc

    lda .map_pos_hi
    adc #>TILE_MAP
    sta .map_pos_hi_t
;    sta .map_pos1 + (22 + 5 + 2)

    lda .pix_pos_hi
    adc #>HIRES
    sta .pix_pos_hi_t

    lda .pix_pos_lo
    sta .pix_pos_lo_t

    lda .scr_pos_hi
    adc #>SCREEN
    sta .scr_pos_hi_t

    lda .scr_pos_hi
    adc #>COLOR_RAM
    sta .clr_pos_hi_t

    lda .scr_pos_lo
    sta .scr_pos_lo_t
}

!macro copy_tile_chars .cols, .count {
!if .cols = 1 {
;    !set .map_pos1 = c_map_pos1
;    !set .map_pos2 = c_map_pos2
    !set .map_pos_lo_t = C_MAP_POS_LO_T
    !set .map_pos_hi_t = C_MAP_POS_HI_T
    !set .pix_pos_lo_t = C_PIX_POS_LO_T
    !set .pix_pos_hi_t = C_PIX_POS_HI_T
    !set .scr_pos_lo_t = C_SCR_POS_LO_T
    !set .scr_pos_hi_t = C_SCR_POS_HI_T
    !set .clr_pos_hi_t = C_CLR_POS_HI_T
} else {
;    !set .map_pos1 = r_map_pos1
;    !set .map_pos2 = r_map_pos2
    !set .map_pos_lo_t = R_MAP_POS_LO_T
    !set .map_pos_hi_t = R_MAP_POS_HI_T
    !set .pix_pos_lo_t = R_PIX_POS_LO_T
    !set .pix_pos_hi_t = R_PIX_POS_HI_T
    !set .scr_pos_lo_t = R_SCR_POS_LO_T
    !set .scr_pos_hi_t = R_SCR_POS_HI_T
    !set .clr_pos_hi_t = R_CLR_POS_HI_T
}
    lda #.count       ; 2 bytes
    sta ITERATIONS    ; 2 bytes

    clc               ; 1 byte

; how about TILE_ROW/COL?
    lda .map_pos_lo_t
    sta MAP_POS_LO_T

    lda .map_pos_hi_t
    sta MAP_POS_HI_T

    lda .scr_pos_lo_t ; 2 bytes
    sta SCR_POS_LO_T  ; 2 bytes
    sta CLR_POS_LO_T  ; 2 bytes

    lda .scr_pos_hi_t ; 2 bytes
    sta SCR_POS_HI_T  ; 2 bytes

    lda .clr_pos_hi_t ; 2 bytes
    sta CLR_POS_HI_T  ; 2 bytes

    lda .pix_pos_lo_t ; 2 bytes
    sta PIX_POS_LO_T  ; 2 bytes

    lda .pix_pos_hi_t ; 2 bytes
    sta PIX_POS_HI_T  ; 2 bytes

.iterate
;-
    +copy_tile_char_and_iterate .cols
    dec ITERATIONS
    beq .exit
    jmp .iterate
;    bne -
.exit

    lda MAP_POS_LO_T
    sta .map_pos_lo_t
    
    lda MAP_POS_HI_T
    sta .map_pos_hi_t

    lda SCR_POS_LO_T
    sta .scr_pos_lo_t

    lda SCR_POS_HI_T
    sta .scr_pos_hi_t

    lda CLR_POS_HI_T
    sta .clr_pos_hi_t

    lda PIX_POS_LO_T
    sta .pix_pos_lo_t

    lda PIX_POS_HI_T
    sta .pix_pos_hi_t

;    ldy .map_pos1 + (22 + 5 + 1)
;    sty .map_pos2 + (22 + 5 + 1)
;    ldy .map_pos1 + (22 + 5 + 2)
;    sty .map_pos2 + (22 + 5 + 2)
}

copy_col_tiles1 !zone {
    +init_pointers 1
;c_map_pos1
    +copy_tile_chars 1, 20
    rts
}

copy_col_tiles2 !zone {
;c_map_pos2
    +copy_tile_chars 1, 20
    rts
}

copy_row_tiles1 !zone {
    +init_pointers SCR_COLS
;r_map_pos1
    +copy_tile_chars SCR_COLS, 11
    rts
}

copy_row_tiles2 !zone {
;r_map_pos2
    +copy_tile_chars SCR_COLS, 12
    rts
}

COPY_TILES !zone {
    ldy C_COPY
    bne .check_copy_col_tiles1
    jsr COPY_ROW_TILES
    rts
.check_copy_col_tiles1
    cpy #2
    bne .check_copy_col_tiles2
    jsr copy_col_tiles1
    ldy #1
    sty C_COPY
    rts
.check_copy_col_tiles2
    cpy #1
    bne .done
    jsr copy_col_tiles2
    ldy #0
    sty C_COPY
.done
    rts
}

COPY_ROW_TILES !zone {
    ldy R_COPY
    bne .check_copy_row_tiles1
    rts
.check_copy_row_tiles1
    cpy #2
    bne .check_copy_row_tiles2
    jsr copy_row_tiles1
    ldy #1
    sty R_COPY
    rts
.check_copy_row_tiles2
    jsr copy_row_tiles2
    ldy #0
    sty R_COPY
    rts
}
