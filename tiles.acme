COPY_COLS = SCROLL_COLS
COPY_ROWS = SCROLL_ROWS

; TILES could be made equal to 256 so that we have nice page boundaries
!macro copy_tile_char .char {
    ldy #0

    lda TILE_CLR+(.char*TILES), x
    sta (CLR_POS_LO_T), y; equals SCR_POS_LO_T, but HI is different

    +set ALL_RAM, RAM_ROM_SELECTION

    lda TILE_SCR+(.char*TILES), x
    sta (SCR_POS_LO_T), y

    !for .row, 0, 7 {
        lda TILE_PIX+(.char*8*TILES)+(.row*TILES), x
        sta (PIX_POS_LO_T), y
        !if .row != 7 {
            iny
        }
    }

    +set ALL_RAM_WITH_IO, RAM_ROM_SELECTION

    rts
}

copy_tile_char0 !zone { +copy_tile_char 0 }
copy_tile_char1 !zone { +copy_tile_char 1 }
copy_tile_char2 !zone { +copy_tile_char 2 }
copy_tile_char3 !zone { +copy_tile_char 3 }
copy_tile_char4 !zone { +copy_tile_char 4 }
copy_tile_char5 !zone { +copy_tile_char 5 }

!macro destination_pointers .cols {
!if .cols = 1 {
    !set .pix_pos_lo_t = PIX_POS_LO_T
    !set .pix_pos_hi_t = PIX_POS_HI_T
    !set .scr_pos_lo_t = SCR_POS_LO_T
    !set .scr_pos_hi_t = SCR_POS_HI_T
    !set .clr_pos_lo_t = CLR_POS_LO_T
    !set .clr_pos_hi_t = CLR_POS_HI_T
} else {
    !set .pix_pos_lo_t = R_PIX_POS_LO_T
    !set .pix_pos_hi_t = R_PIX_POS_HI_T
    !set .scr_pos_lo_t = R_SCR_POS_LO_T
}

    ; pixel pointer
    lda .pix_pos_lo_t
    adc #(8*.cols % 256) ; + 64
    sta .pix_pos_lo_t

    lda .pix_pos_hi_t
    adc #(8*.cols / 256) ; + 256
    and #%11011111 ; modulo 8192 (but keep upper bits)
    sta .pix_pos_hi_t ; next pixel position to start from

    ; color pointers
    lda .scr_pos_lo_t
    adc #.cols
    sta .scr_pos_lo_t ; next screen position to start from
    sta .clr_pos_lo_t
    bcc +
    clc

    lda .scr_pos_hi_t
    adc #1
    and #%11111011 ; modulo 1024 (but keep upper bits)
    sta .scr_pos_hi_t

    lda .clr_pos_hi_t
    adc #1
    and #%11111011 ; module 1024 (but keep upper bits)
    sta .clr_pos_hi_t
+
}

!macro source_pointers .cols {
!if .cols = 1 {
    !set .tile_col = C_TILE_COL
    !set .tile_row = C_TILE_ROW
} else {
    !set .tile_col = R_TILE_COL
    !set .tile_row = R_TILE_ROW
}

.map_pos
    ldx TILE_MAP           ; x = tile index

    ; pixel pointer
    lda .tile_row
    beq +
    lda #TILE_COLS         ; a = TILE_COLS * tile_row (TILE_ROWS = 2)
+
    adc .tile_col

    ; use char and tile index to copy_tile_chars
    !for .char, 0, 5 {
        !if .char != 5 {
            cmp #.char
            bne +
        }
        !if .char = 0 { jsr copy_tile_char0 }
        !if .char = 1 { jsr copy_tile_char1 }
        !if .char = 2 { jsr copy_tile_char2 }
        !if .char = 3 { jsr copy_tile_char3 }
        !if .char = 4 { jsr copy_tile_char4 }
        !if .char = 5 { jsr copy_tile_char5 }
        !if .char != 5 {
            jmp .iterate
        }
+
    }

.iterate
    clc
    +destination_pointers 1

!if .cols = 1 {
    lda .tile_col
    adc #1
    cmp #TILE_COLS
    sta .tile_col
    bne +
    clc
    lda #0
    sta .tile_col

    inc .map_pos + 1
    bne +
    inc .map_pos + 2
+
} else {
    lda .tile_row ; tile_row = (tile_row + 1) % 2 (TILE_ROWS = 2)
    adc #1
    and #1
    sta .tile_row
    bne +

;    lda .tile_row
;    adc #1
;    cmp #TILE_ROWS
;    sta .tile_row
;    bne +
;    clc
;    lda #0
;    sta .tile_row

    ; example map is 256 tiles wide
    ; lda .map_pos_lo_t
    ; adc #MAP_WIDTH
    ; sta .map_pos_lo_t
    ; bcc +
    ; clc
    inc .map_pos + 2
+
}

}

!macro init_destination_pointers .cols {
!if .cols = 1 {
    !set .pix_pos_lo = C_PIX_POS_LO
    !set .pix_pos_hi = C_PIX_POS_HI
    !set .scr_pos_lo = C_SCR_POS_LO
    !set .scr_pos_hi = C_SCR_POS_HI
    !set .pix_pos_lo_t = C_PIX_POS_LO_T
    !set .pix_pos_hi_t = C_PIX_POS_HI_T
    !set .scr_pos_lo_t = C_SCR_POS_LO_T
    !set .scr_pos_hi1_t = C_SCR_POS_HI1_T
    !set .scr_pos_hi2_t = C_SCR_POS_HI2_T
} else {
    !set .pix_pos_lo = R_PIX_POS_LO
    !set .pix_pos_hi = R_PIX_POS_HI
    !set .scr_pos_lo = R_SCR_POS_LO
    !set .scr_pos_hi = R_SCR_POS_HI
    !set .pix_pos_lo_t = R_PIX_POS_LO_T
    !set .pix_pos_hi_t = R_PIX_POS_HI_T
    !set .scr_pos_lo_t = R_SCR_POS_LO_T
    !set .scr_pos_hi1_t = R_SCR_POS_HI1_T
    !set .scr_pos_hi2_t = R_SCR_POS_HI2_T
}
    clc
    lda .pix_pos_hi
    adc #>HIRES
    sta .pix_pos_hi_t

    lda .pix_pos_lo
    sta .pix_pos_lo_t

    lda .scr_pos_hi
    adc #>SCREEN
    sta .scr_pos_hi1_t

    lda .scr_pos_hi
    adc #>COLOR_RAM
    sta .scr_pos_hi2_t

    lda .scr_pos_lo
    sta .scr_pos_lo_t
}

!macro init_source_pointers .cols {
!if .cols = 1 {
    !set .map_pos_lo = C_MAP_POS_LO
    !set .map_pos_hi = C_MAP_POS_HI
    !set .map_pos1 = c_map_pos1
    !set .tile_col = C_TILE_COL
    !set .tile_row = C_TILE_ROW
} else {
    !set .map_pos_lo = R_MAP_POS_LO
    !set .map_pos_hi = R_MAP_POS_HI
    !set .map_pos1 = r_map_pos1
    !set .tile_col = R_TILE_COL
    !set .tile_row = R_TILE_ROW
}
    lda TILE_COL
    sta .tile_col
    lda TILE_ROW
    sta .tile_row

    lda .map_pos_lo
    sta .map_pos1 + (5 + 1)

    lda .map_pos_hi
    sta .map_pos1 + (5 + 2)
}

!macro iterate_source_pointers .cols, .count {
!if .cols = 1 {
;    !set .map_pos1 = c_map_pos1
;    !set .map_pos2 = c_map_pos2
} else {
    !set .map_pos1 = r_map_pos1
    !set .map_pos2 = r_map_pos2
}
    lda #.count       ; 2 bytes
    sta ITERATIONS    ; 2 bytes

    clc               ; 1 byte
.iterate
    +source_pointers .cols
    dec ITERATIONS
    beq .exit
    jmp .iterate
;    bne -
.exit
;    ldy .map_pos1 + (26 + 5 + 1)
;    sty .map_pos2 + (26 + 5 + 1)
;    ldy .map_pos1 + (26 + 5 + 2)
;    sty .map_pos2 + (26 + 5 + 2)
}

!macro iterate_destination_pointers .cols, .count {
!if .cols = 1 {
    !set .scr_pos_hi1_t = C_SCR_POS_HI1_T
    !set .scr_pos_hi2_t = C_SCR_POS_HI2_T
} else {
    !set .scr_pos_hi1_t = R_SCR_POS_HI1_T
    !set .scr_pos_hi2_t = R_SCR_POS_HI2_T
}
    lda #.count
    sta ITERATIONS

    clc
    ldx .scr_pos_hi1_t
    ldy .scr_pos_hi2_t
-
    +destination_pointers .cols
    dec ITERATIONS
    bne -

    stx .scr_pos_hi1_t
    sty .scr_pos_hi2_t
}

set_col_pointers1 !zone {
    +init_source_pointers 1
    +init_destination_pointers 1

lda C_SCR_POS_LO_T
sta SCR_POS_LO_T
sta CLR_POS_LO_T
lda C_SCR_POS_HI1_T
sta SCR_POS_HI_T
lda C_SCR_POS_HI2_T
sta CLR_POS_HI_T
lda C_PIX_POS_LO_T
sta PIX_POS_LO_T
lda C_PIX_POS_HI_T
sta PIX_POS_HI_T

c_map_pos1
+iterate_source_pointers 1, 40
rts

;c_map_pos1
    +iterate_source_pointers 1, 10
    +iterate_destination_pointers 1, 26
;    +iterate_source_pointers 1, 15
;    +iterate_destination_pointers 1, 10
    rts
}

set_col_pointers2 !zone {
;c_map_pos2
    +iterate_source_pointers 1, 30
    +iterate_destination_pointers 1, 4
;    +iterate_source_pointers 1, 14
;    +iterate_destination_pointers 1, 10
    rts
}

!macro set_col_pointers3 {
    +iterate_destination_pointers 1, 10
;    +iterate_destination_pointers 1, 9
}

!macro set_row_pointers1 {
    +init_source_pointers SCR_COLS
    +init_destination_pointers SCR_COLS
r_map_pos1
    +iterate_source_pointers SCR_COLS, 13
;    +iterate_destination_pointers SCR_COLS, 13
}

!macro set_row_pointers2 {
r_map_pos2
    +iterate_source_pointers SCR_COLS, 10
;    +iterate_destination_pointers SCR_COLS, 10
}

COPY_TILES !zone {
    ldy C_COPY_PIX
    bpl .check_pointers1
;    jsr COPY_ROW_TILES
    rts
.check_pointers1
    cpy #9
    bne .check_pointers2
    jsr set_col_pointers1
    ldy #$ff
;    ldy #8
    sty C_COPY_PIX
    rts
.check_pointers2
    cpy #8
    bne .copy_pixels
    jsr set_col_pointers2
    ldy #7
    sty C_COPY_PIX
    rts
.copy_pixels
    +set_col_pointers3
    rts
}

COPY_ROW_TILES !zone {
    ldy R_COPY_PIX
    bpl .check_pointers1
    rts
.check_pointers1
    cpy #9
    beq .set_pointers1
    jmp .copy_pixels
.set_pointers1
    +set_row_pointers1
    ldy #7
    sty R_COPY_PIX
    rts
.copy_pixels
    +set_row_pointers2
    rts
}
